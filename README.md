# bjo

Данная библиотека призвана упростить процесс написания асинхронных приложений, использующих
```boost::asio``` и ```boost::beast```. Использование bjo делает c++ код, решающий типовые высокоуровневые задачи, более
читабельным и
простым для восприятия, без ущерба производительности.

Библиотека bjo предоставляет удобные и эффективные абстракции для написания асинхронных приложений. Приоритетный способ
написания асинхронного кода в bjo - это корутины,
которые вошли в стандарт языка C++ в 2020 году. Предполагается, что пользователь библиотеки будет использовать именно
их, в процессе написания кода, несмотря на то, что
альтернативные подходы к написанию асинхронного кода тоже поддерживаются.


# Установка
Чтобы использовать библиотеку в своем C++ проекте, ее нужно подключить как CMake подпроект:

```cmake
add_subdirectory(bjo)
include_directories(bjo/include)
target_link_libraries(${PROJECT_NAME} bjo)
```

И установить зависимости с помощью ```conan```.

```shell
conan install <путь до conanfile.txt, который лежит в папке с библиотекой>
```


## Что такое корутины?

Корутина - это функция, которая может приостановить свое выполнение на какое-то время или до наступления какого-то
события,
а после возобновиться с того места, где была приостановлена. При этом не обязательно, что в том же потоке, где была до
этого.

Корутины позволяют писать асинхронный код, который выглядит как синхронный. Это очень круто, честно.

## Как написать корутину в boost::asio

* Чтобы ваша функция стала корутиной, нужно чтобы она возвращала ```boost::asio::awaitable<ТИП ДАННЫХ>```.
  После этого, в ее теле станет возможно использовать такие ключевые слова как ```co_return``` и ```co_await```. Но! уже
  нельзя использовать
  обычный ```return```.
* Чтобы запустить свою корутину, ее нужно создать(заспавнить) в executor-e. Для этого нужно написать следующий код:

```c++
boost::asio::co_spawn(
        экземпляр io_context, или другой executor из asio,
        вызов вашей корутины, 
        указать completion_token  
);
```

* Про completion_token-ы написано здесь:
  https://www.boost.org/doc/libs/develop/doc/html/boost_asio/overview/model/completion_tokens.html

Для работы с c++20 корутинами используются 2 токена:

* ```boost::asio::use_awaitable``` - для того, чтобы иметь возможность отпустить контекст, до тех пор, пока задача не
  будет выполнена
* ```boost::asio::detached``` - отправить корутину в "свободное плавание". Заспавнить ее в исполнителе и никак не
  дожидаться ее завершения

## Основные компоненты фреймворка:

### TaskProcessor

Важнейшим классом библиотеки является ```TaskProcessor```, который представляет собой обертку
над ```boost::asio::io_context```, позволяющую исполнять асинхронные задачи в собственном пуле потоков, не блокируя
вызвавший поток.

#### Зачем это нужно?

Иногда в асинхронном приложении может возникать необходимость запустить сложные CPU-bound вычисления, или обратиться к
БД.
Возникает проблема. Например, если запустить такую операцию в потоке, принимающем новые соединения (предположим, что мы
пишем http-сервер) мы заблокируемся до окончания тяжелой операции.
Это чревато тем, что мы перестанем обслуживать клиентов на какое-то время.

Исполнение задач в разных TaskProcessor-ах решает данную проблему. Пользователь библиотеки может определить
TaskProcessor-ы на типы решаемых задач и
запускать таски(корутины, коллбэки, футуры) в соответствующих Executor-ах.

#### Что ещё?

Пользователь может выбрать то, каким образом запустить асинхронную задачу. Можно использовать как стандартные корутины,
так и ```std::future``` или классические callback-и. 
#### Пример использования:
### http::Server

bjo предоставляет пользователю удобную и эффективную высокоуровневую абстракцию, позволяющую реализовывать http серверы.

#### Как этим пользоваться?

Для того чтобы запустить http::Server в bjo нужно:

* Задать обработчики на соответствующие таргеты (об этом позже)
* Зарегистрировать их в сервере
* Запустить сервер

#### ПРИМЕР:

```c++
  using namespace bjo;
  http::server::Server server(http::server::DefaultConfig()); 
  server.RegisterHandlers()
      (http::METHODS::GET | http::METHODS::POST, std::make_unique<Handler>())
      (http::METHODS::GET, std::make_unique<HandlerTwo>())
      (http::METHODS::GET, std::make_unique<HandleFavicon>())
  ;
  server.Serve(); // Start server
```

#### ВАЖНО

* При регистрации обработчика, сервер ожидает получить ```std::unique_ptr``` на класс-наследник от
  ```bjo::http::server::HandlerBase```. Я принял решение использовать динамический полиморфизм для того, чтобы у
  пользователя
  была возможность использовать библиотеку ```ctre``` при проверке и парсинге заголовков в обработчиках.

#### ПРИМЕР ОБРАБОТЧИКА

```c++
class Handler : public bjo::http::server::HandlerBase
{
public:
  // Паттерн подходящего таргета
  static constexpr ctll::fixed_string route = "/hello/id=[0-9]+/world/[0-9a-z]+"; 

  bool CanHandle(std::string_view target) const override
  {
    /*
     * Здесь мы должны проверить и дать сигнал, что данный обработчик может запуститься на этот запрос 
     * Так роутер поймет, что этот обработчик должен быть вызван.
     */
    return ctre::match<route>(target);
  }

  // Метод обработки запроса
  boost::asio::awaitable<http::Response> Handle(const http::Request&) const override
  {
    http::Response result = {};
    /*
     * Здесь начинается бизнес-логика
     */
    result.prepare_payload();
    co_return result;
  }
};
```

Впринципе, пользователь может реализовывать метод проверки любым удобным ему способом

Классы ```bjo::http::Request``` и ```bjo::http::Response``` - это alias-ы для реализаций из boost::beast.

